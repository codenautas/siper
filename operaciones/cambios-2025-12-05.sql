-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 

set search_path = siper;

-- Type: detalle_novedades_multiorigen

-- DROP TYPE IF EXISTS siper.detalle_novedades_multiorigen;

DROP FUNCTION IF EXISTS siper.detalle_nov_multiorigen(p_usados bigint, p_pendientes bigint, p_esquema text);

CREATE TYPE siper.detalle_novedades_multiorigen AS
(
	origen text,
	cantidad integer,
	usados integer,
	pendientes integer,
	saldo integer,
    comienzo date,
    vencimiento date
);

ALTER TYPE siper.detalle_novedades_multiorigen
    OWNER TO siper_muleto_owner;



CREATE OR REPLACE TRIGGER changes_trg
    AFTER INSERT OR DELETE OR UPDATE 
    ON siper.fichadas
    FOR EACH ROW
    EXECUTE FUNCTION his.changes_trg('idper,fecha,hora,id_fichada');

CREATE OR REPLACE FUNCTION siper.detalle_nov_multiorigen(
	p_fechas date[],
	p_esquema text)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    IMMUTABLE PARALLEL UNSAFE
AS $BODY$
DECLARE
  v_esquema record;
  v_renglon detalle_novedades_multiorigen;
  v_detalles detalle_novedades_multiorigen[] := array[]::detalle_novedades_multiorigen[];
  -- Locales al loop:
  v_resto integer;
  i integer := 1;
  v_inconsistencias integer := 0;
  v_mensajes text[] := array[]::text[];
  v_result jsonb := '{}'::jsonb;
BEGIN
  IF p_esquema IS null THEN
    RETURN '{"detalle":[]}';
  ELSE
    FOR v_esquema IN 
      SELECT key AS origen, (value->>'cantidad')::integer AS cantidad, (value->>'comienzo')::date AS comienzo, (value->>'vencimiento')::date AS vencimiento
        FROM jsonb_each(p_esquema::jsonb)
        ORDER BY key
    LOOP
      RAISE NOTICE 'ESTOY %', v_esquema;
      v_renglon.cantidad := v_esquema.cantidad;
      v_renglon.saldo := v_esquema.cantidad;
      v_renglon.origen := v_esquema.origen;
      v_renglon.usados := null;
      v_renglon.pendientes := null;
      WHILE CASE WHEN i > ARRAY_LENGTH(p_fechas, 1) OR p_fechas is null THEN FALSE 
        ELSE v_renglon.saldo > 0 AND (v_esquema.vencimiento IS NULL OR p_fechas[i] <= v_esquema.vencimiento) END 
      LOOP
        RAISE NOTICE 'TENGO % % % i:% %', v_renglon.saldo, i, p_fechas[i], p_fechas[i] < v_esquema.comienzo, p_fechas[i] <= v_esquema.vencimiento;
        IF p_fechas[i] < v_esquema.comienzo THEN
          v_inconsistencias := v_inconsistencias + 1;
        ELSE
          v_renglon.saldo := (v_renglon.saldo - 1);
          IF p_fechas[i] <= fecha_actual() THEN
            v_renglon.usados := COALESCE(v_renglon.usados, 0) + 1;
          ELSE
            v_renglon.pendientes := COALESCE(v_renglon.pendientes, 0) + 1;
          END IF;
        END IF;
        i := i + 1;
      END LOOP;
      v_detalles := v_detalles || v_renglon;
      RAISE NOTICE 'END LOOP % %', v_detalles, v_inconsistencias;
    END LOOP;
    if v_inconsistencias > 0 then 
      v_mensajes := array_append(v_mensajes, 'inconsistencia ' || v_inconsistencias || ' fecha(s) en brecha agotada');
    end if; 
    RAISE NOTICE 'MENSAJES % %', v_mensajes, v_inconsistencias;
    v_inconsistencias := ARRAY_LENGTH(p_fechas, 1) - i + 1;
    if v_inconsistencias > 0 then 
      v_mensajes := array_append(v_mensajes, 'inconsistencia ' || v_inconsistencias || ' fecha(s) pasado el limite');
    end if;
    RAISE NOTICE 'MENSAJES % %', v_mensajes, v_inconsistencias;
    v_result := jsonb_build_object('detalle', to_jsonb(v_detalles));
    if array_length(v_mensajes, 1) >0 then
      v_result := v_result || jsonb_build_object('error', to_jsonb(v_mensajes));
    end if; --1
    RETURN v_result::text;
  END IF;
END;
$BODY$;

ALTER FUNCTION siper.detalle_nov_multiorigen(date[], text)
    OWNER TO siper_muleto_owner;

CREATE OR REPLACE PROCEDURE siper.avance_de_dia_proc(
	)
LANGUAGE 'sql'
    SECURITY DEFINER 

BEGIN ATOMIC
 UPDATE siper.fechas f SET cod_nov_pred_fecha = parametros.cod_nov_habitual
    FROM siper.parametros,
     siper.annios a
   WHERE ((f.cod_nov_pred_fecha IS NULL) AND (f.fecha <= siper.fecha_actual()) AND (f.annio = a.annio) AND a.abierto);
END;

ALTER PROCEDURE siper.avance_de_dia_proc()
    OWNER TO siper_muleto_owner;

CREATE OR REPLACE FUNCTION siper.parametros_avance_dia_trg()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
  CALL avance_de_dia_proc();
  RETURN new;
END;
$BODY$;

ALTER FUNCTION siper.parametros_avance_dia_trg()
    OWNER TO siper_muleto_owner;


ALTER TABLE IF EXISTS siper.parametros DROP COLUMN IF EXISTS avance_dia_automatico;

ALTER TABLE IF EXISTS siper.parametros DROP COLUMN IF EXISTS fecha_actual_no_usar;
CREATE OR REPLACE TRIGGER parametros_avance_dia_trg
    AFTER UPDATE OF fecha_hora_para_test
    ON siper.parametros
    FOR EACH ROW
    EXECUTE FUNCTION siper.parametros_avance_dia_trg();
DROP TRIGGER IF EXISTS parametros_trg ON siper.parametros;


DROP FUNCTION siper.parametros_trg();

DROP TRIGGER IF EXISTS parametros_avance_dia_trg ON siper.parametros;

set search_path = siper;

select annio_preparar(2026);
update annios set abierto = true where annio=2026
call inicializar_per_nov_cant(2026);

update per_nov_cant set vencimiento = '2025-12-31' 
  where cod_nov = '1' and origen='2023';

update per_nov_cant set vencimiento = null, comienzo = null
  where cod_nov = '1' and origen='2024';

update per_nov_cant set vencimiento = null, comienzo = null
  where cod_nov = '1' and origen='2025';

