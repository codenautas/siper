-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 

set search_path = siper;

-- Type: detalle_novedades_multiorigen

-- DROP TYPE IF EXISTS siper.detalle_novedades_multiorigen;

CREATE TYPE siper.detalle_novedades_multiorigen AS
(
	origen text,
	cantidad integer,
	usados integer,
	pendientes integer,
	saldo integer
);

ALTER TYPE siper.detalle_novedades_multiorigen
    OWNER TO siper_muleto_owner;



CREATE OR REPLACE TRIGGER changes_trg
    AFTER INSERT OR DELETE OR UPDATE 
    ON siper.fichadas
    FOR EACH ROW
    EXECUTE FUNCTION his.changes_trg('idper,fecha,hora,id_fichada');
CREATE OR REPLACE FUNCTION siper.detalle_nov_multiorigen(
	p_usados bigint,
	p_pendientes bigint,
	p_esquema text)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    IMMUTABLE PARALLEL UNSAFE
AS $BODY$
DECLARE
  v_esquema record;
  v_usados integer;
  v_pendientes integer;
  v_renglon detalle_novedades_multiorigen;
  v_result detalle_novedades_multiorigen[] := array[]::detalle_novedades_multiorigen[];
  -- Locales al loop:
  v_resto integer;
BEGIN
  IF p_esquema IS null THEN
    RETURN null;
  ELSE
    v_usados := coalesce(p_usados, 0);
    v_pendientes := coalesce(p_pendientes, 0);
    FOR v_esquema IN 
      SELECT key AS origen, (value->>'cantidad')::integer AS cantidad
        FROM jsonb_each(p_esquema::jsonb)
        ORDER BY key
    LOOP
      v_renglon.cantidad := v_esquema.cantidad;
      v_renglon.origen := v_esquema.origen;
      v_renglon.usados := case when v_usados > v_renglon.cantidad then v_renglon.cantidad else v_usados end;
      v_usados := v_usados - v_renglon.usados;
      v_resto := v_renglon.cantidad - v_renglon.usados;
      v_renglon.pendientes := case when v_pendientes > v_resto then v_resto else v_pendientes end;
      v_pendientes := v_pendientes - v_renglon.pendientes;
      v_renglon.saldo := v_renglon.cantidad - (v_renglon.usados + v_renglon.pendientes);
      v_result := v_result || v_renglon;
    END LOOP;
    IF v_usados > 0 OR v_pendientes > 0 THEN
      v_renglon.origen := 'inconsistencia';
      v_renglon.cantidad := null;
      v_renglon.usados := v_usados;
      v_renglon.penientes := v_pendientes;
      v_renglon.saldo := - v_usados - v_pendientes;
      v_result := v_result || v_renglon;
    END IF;
    RETURN to_jsonb(v_result)::text;
  END IF;
END;
$BODY$;

ALTER FUNCTION siper.detalle_nov_multiorigen(bigint, bigint, text)
    OWNER TO siper_muleto_owner;

CREATE OR REPLACE PROCEDURE siper.avance_de_dia_proc(
	)
LANGUAGE 'sql'
    SECURITY DEFINER 

BEGIN ATOMIC
 UPDATE siper.fechas f SET cod_nov_pred_fecha = parametros.cod_nov_habitual
    FROM siper.parametros,
     siper.annios a
   WHERE ((f.cod_nov_pred_fecha IS NULL) AND (f.fecha <= siper.fecha_actual()) AND (f.annio = a.annio) AND a.abierto);
END;

ALTER PROCEDURE siper.avance_de_dia_proc()
    OWNER TO siper_muleto_owner;

CREATE OR REPLACE FUNCTION siper.parametros_avance_dia_trg()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
  CALL avance_de_dia_proc();
  RETURN new;
END;
$BODY$;

ALTER FUNCTION siper.parametros_avance_dia_trg()
    OWNER TO siper_muleto_owner;


ALTER TABLE IF EXISTS siper.parametros DROP COLUMN IF EXISTS avance_dia_automatico;

ALTER TABLE IF EXISTS siper.parametros DROP COLUMN IF EXISTS fecha_actual_no_usar;
CREATE OR REPLACE TRIGGER parametros_avance_dia_trg
    AFTER UPDATE OF fecha_hora_para_test
    ON siper.parametros
    FOR EACH ROW
    EXECUTE FUNCTION siper.parametros_avance_dia_trg();
DROP TRIGGER IF EXISTS parametros_trg ON siper.parametros;


DROP FUNCTION siper.parametros_trg();
