-- This script was generated by the Schema Diff utility in pgAdmin 4. 
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated 
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps. 
 CREATE TABLE IF NOT EXISTS siper.avisos_falta_fichada
(
    idper text COLLATE pg_catalog."default" NOT NULL,
    fecha date NOT NULL,
    tipo_fichada text COLLATE pg_catalog."default" NOT NULL,
    avisado_wp time without time zone,
    avisado_mail time without time zone,
    llegada_novedad time without time zone,
    CONSTRAINT avisos_falta_fichada_pkey PRIMARY KEY (idper, fecha, tipo_fichada),
    CONSTRAINT "avisos_falta_fichada personas REL" FOREIGN KEY (idper)
        REFERENCES siper.personas (idper) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE NO ACTION,
    CONSTRAINT "idper<>''" CHECK (idper <> ''::text),
    CONSTRAINT "tipo_fichada<>''" CHECK (tipo_fichada <> ''::text)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS siper.avisos_falta_fichada
    OWNER to siper_muleto_owner;

GRANT SELECT ON TABLE siper.avisos_falta_fichada TO siper_muleto_admin;

GRANT ALL ON TABLE siper.avisos_falta_fichada TO siper_muleto_owner;
CREATE INDEX IF NOT EXISTS "idper 4 avisos_falta_fichada IDX"
    ON siper.avisos_falta_fichada USING btree
    (idper COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

CREATE OR REPLACE TRIGGER changes_trg
    AFTER INSERT OR DELETE OR UPDATE 
    ON siper.avisos_falta_fichada
    FOR EACH ROW
    EXECUTE FUNCTION his.changes_trg('idper,fecha,tipo_fichada');
CREATE TABLE IF NOT EXISTS siper.reglas
(
    annio integer NOT NULL,
    codnov_unica_fichada text COLLATE pg_catalog."default",
    codnov_sin_fichadas text COLLATE pg_catalog."default",
    umbral_horas_mensuales integer,
    umbral_horas_diarias integer,
    umbral_horas_semanales integer,
    umbral_horas_personales integer,
    horario_consolidado time without time zone,
    minimas_horas_diarias_declaradas integer,
    maximas_horas_diarias_declaradas integer,
    CONSTRAINT reglas_pkey PRIMARY KEY (annio),
    CONSTRAINT "codnov_sin_fichadas<>''" CHECK (codnov_sin_fichadas <> ''::text),
    CONSTRAINT "codnov_unica_fichada<>''" CHECK (codnov_unica_fichada <> ''::text)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS siper.reglas
    OWNER to siper_muleto_owner;

GRANT SELECT ON TABLE siper.reglas TO siper_muleto_admin;

GRANT ALL ON TABLE siper.reglas TO siper_muleto_owner;

CREATE OR REPLACE TRIGGER changes_trg
    AFTER INSERT OR DELETE OR UPDATE 
    ON siper.reglas
    FOR EACH ROW
    EXECUTE FUNCTION his.changes_trg('annio');
CREATE TABLE IF NOT EXISTS siper.tipos_fichada
(
    tipo_fichada text COLLATE pg_catalog."default" NOT NULL,
    nombre text COLLATE pg_catalog."default" NOT NULL,
    orden integer NOT NULL,
    CONSTRAINT tipos_fichada_pkey PRIMARY KEY (tipo_fichada),
    CONSTRAINT "nombre<>''" CHECK (nombre <> ''::text),
    CONSTRAINT "tipo_fichada<>''" CHECK (tipo_fichada <> ''::text)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS siper.tipos_fichada
    OWNER to siper_muleto_owner;

GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE siper.tipos_fichada TO siper_muleto_admin;

GRANT ALL ON TABLE siper.tipos_fichada TO siper_muleto_owner;

CREATE OR REPLACE TRIGGER changes_trg
    AFTER INSERT OR DELETE OR UPDATE 
    ON siper.tipos_fichada
    FOR EACH ROW
    EXECUTE FUNCTION his.changes_trg('tipo_fichada');
ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN cuenta_horas boolean;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN eximido_fichar boolean;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN inicializacion text COLLATE pg_catalog."default";

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN inicializacion_limite integer;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN necesita_verificacion_manual boolean;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN pierde_presentismo boolean;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN requiere_entrada boolean;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN requiere_fichadas boolean;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN requiere_ninguna_fichada boolean;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN umbral_anterior_salida integer;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD COLUMN umbral_posterior_entrada integer;

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD CONSTRAINT "inicializacion<>''" CHECK (inicializacion <> ''::text);

ALTER TABLE IF EXISTS siper.cod_novedades
    ADD CONSTRAINT "inicializacion lista de metodos" CHECK (inicializacion = ANY (ARRAY['LICORD'::text, 'LICMAT'::text, 'PLANTA'::text]));
ALTER TABLE IF EXISTS siper.parametros DROP COLUMN IF EXISTS avance_dia_automatico;

ALTER TABLE IF EXISTS siper.parametros DROP COLUMN IF EXISTS fecha_actual;

ALTER TABLE IF EXISTS siper.parametros
    ADD COLUMN carga_nov_hasta_hora time without time zone NOT NULL DEFAULT '12:00:00'::time without time zone;

ALTER TABLE IF EXISTS siper.parametros
    ADD COLUMN fecha_hora_para_test timestamp without time zone;

ALTER TABLE IF EXISTS siper.parametros
    ADD COLUMN permite_cargar_fichadas boolean DEFAULT true;

ALTER TABLE IF EXISTS siper.parametros
    ADD CONSTRAINT parametros_permite_cargar_fichadas_check CHECK (permite_cargar_fichadas IS NOT FALSE);
REVOKE ALL ON TABLE siper.per_telefonos FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.per_telefonos FROM siper_muleto_owner;
GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE siper.per_telefonos TO siper_muleto_admin;

GRANT ALL ON TABLE siper.per_telefonos TO siper_muleto_owner;
REVOKE ALL ON TABLE siper.adjuntos FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.adjuntos FROM siper_muleto_owner;
GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE siper.adjuntos TO siper_muleto_admin;

GRANT ALL ON TABLE siper.adjuntos TO siper_muleto_owner;
REVOKE ALL ON TABLE siper.adjuntos_atributos FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.adjuntos_atributos FROM siper_muleto_owner;
GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE siper.adjuntos_atributos TO siper_muleto_admin;

GRANT ALL ON TABLE siper.adjuntos_atributos TO siper_muleto_owner;
ALTER TABLE IF EXISTS siper.annios
    ADD COLUMN anterior integer;
ALTER TABLE IF EXISTS siper.annios
    ADD CONSTRAINT "annios ant REL" FOREIGN KEY (anterior)
    REFERENCES siper.annios (annio) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS "anterior 4 annios IDX"
    ON siper.annios USING btree
    (anterior ASC NULLS LAST)
    TABLESPACE pg_default;

REVOKE ALL ON TABLE siper.trayectoria_laboral FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.trayectoria_laboral FROM siper_muleto_owner;
GRANT DELETE, INSERT, SELECT, UPDATE ON TABLE siper.trayectoria_laboral TO siper_muleto_admin;

GRANT ALL ON TABLE siper.trayectoria_laboral TO siper_muleto_owner;
REVOKE ALL ON TABLE siper.fichadas FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.fichadas FROM siper_muleto_owner;
GRANT DELETE, INSERT, SELECT, UPDATE ON TABLE siper.fichadas TO siper_muleto_admin;

GRANT ALL ON TABLE siper.fichadas TO siper_muleto_owner;

ALTER TABLE IF EXISTS siper.fichadas DROP COLUMN IF EXISTS origen;

ALTER TABLE IF EXISTS siper.fichadas
    ADD COLUMN id_fichada bigint NOT NULL DEFAULT nextval('siper.id_fichada_seq'::regclass);

ALTER TABLE IF EXISTS siper.fichadas
    ADD COLUMN annio integer GENERATED ALWAYS AS (EXTRACT(year FROM fecha)) STORED;

ALTER TABLE IF EXISTS siper.fichadas
    ADD COLUMN tipo_fichada text COLLATE pg_catalog."default" NOT NULL;

ALTER TABLE IF EXISTS siper.fichadas
    ADD COLUMN observaciones text COLLATE pg_catalog."default";

ALTER TABLE IF EXISTS siper.fichadas
    ADD COLUMN punto text COLLATE pg_catalog."default";

ALTER TABLE IF EXISTS siper.fichadas
    ADD COLUMN tipo_dispositivo text COLLATE pg_catalog."default";

ALTER TABLE IF EXISTS siper.fichadas
    ADD COLUMN id_original text COLLATE pg_catalog."default";
ALTER TABLE IF EXISTS siper.fichadas
    ADD CONSTRAINT fichadas_pkey PRIMARY KEY (idper, fecha, hora, id_fichada);

ALTER TABLE IF EXISTS siper.fichadas
    ADD CONSTRAINT "fichadas annios REL" FOREIGN KEY (annio)
    REFERENCES siper.annios (annio) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;

ALTER TABLE IF EXISTS siper.fichadas
    ADD CONSTRAINT "fichadas tipos_fichada REL" FOREIGN KEY (tipo_fichada)
    REFERENCES siper.tipos_fichada (tipo_fichada) MATCH SIMPLE
    ON UPDATE CASCADE
    ON DELETE NO ACTION;
ALTER TABLE IF EXISTS siper.fichadas DROP CONSTRAINT IF EXISTS "origen<>''";

ALTER TABLE IF EXISTS siper.fichadas
    ADD CONSTRAINT "tipo_fichada<>''" CHECK (tipo_fichada <> ''::text);

ALTER TABLE IF EXISTS siper.fichadas
    ADD CONSTRAINT "observaciones<>''" CHECK (observaciones <> ''::text);

ALTER TABLE IF EXISTS siper.fichadas
    ADD CONSTRAINT "punto<>''" CHECK (punto <> ''::text);

ALTER TABLE IF EXISTS siper.fichadas
    ADD CONSTRAINT "tipo_dispositivo<>''" CHECK (tipo_dispositivo <> ''::text);

ALTER TABLE IF EXISTS siper.fichadas
    ADD CONSTRAINT "id_original<>''" CHECK (id_original <> ''::text);
CREATE INDEX IF NOT EXISTS "tipo_fichada 4 fichadas IDX"
    ON siper.fichadas USING btree
    (tipo_fichada COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS "annio 4 fichadas IDX"
    ON siper.fichadas USING btree
    (annio ASC NULLS LAST)
    TABLESPACE pg_default;

DROP TRIGGER IF EXISTS changes_trg ON siper.fichadas;
REVOKE ALL ON TABLE siper.capacitaciones FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.capacitaciones FROM siper_muleto_owner;
GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE siper.capacitaciones TO siper_muleto_admin;

GRANT ALL ON TABLE siper.capacitaciones TO siper_muleto_owner;
REVOKE ALL ON TABLE siper.grupos FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.grupos FROM siper_muleto_owner;
GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE siper.grupos TO siper_muleto_admin;

GRANT ALL ON TABLE siper.grupos TO siper_muleto_owner;
ALTER TABLE IF EXISTS siper.niveles_educativos
    ADD CONSTRAINT "nivel_educativo<>''" CHECK (nivel_educativo <> ''::text);
ALTER TABLE IF EXISTS siper.situacion_revista
    ADD COLUMN ini_per_nov_cant boolean;
REVOKE ALL ON TABLE siper.nov_gru FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.nov_gru FROM siper_muleto_owner;
GRANT INSERT, SELECT, UPDATE, DELETE ON TABLE siper.nov_gru TO siper_muleto_admin;

GRANT ALL ON TABLE siper.nov_gru TO siper_muleto_owner;


ALTER POLICY "bp insert" ON siper.novedades_horarias
    WITH CHECK ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_horarias.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_horarias.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (fecha > siper.fecha_actual()) THEN true
    WHEN (fecha < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));

ALTER POLICY "bp update" ON siper.novedades_horarias
    USING ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_horarias.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_horarias.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (fecha > siper.fecha_actual()) THEN true
    WHEN (fecha < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));

ALTER POLICY "bp delete" ON siper.novedades_horarias
    USING ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_horarias.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_horarias.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (fecha > siper.fecha_actual()) THEN true
    WHEN (fecha < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));

--DROP TRIGGER IF EXISTS tr_validar_usuario ON siper.usuarios;

ALTER TABLE IF EXISTS siper.personas
    ADD CONSTRAINT "max_nivel_ed<>''" CHECK (max_nivel_ed <> ''::text);

ALTER INDEX IF EXISTS siper."perfiles_sgc 4 personas IDX" RENAME TO siper."perfil_sgc 4 personas IDX";


ALTER POLICY "bp insert" ON siper.novedades_vigentes
    WITH CHECK ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_vigentes.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_vigentes.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (fecha > siper.fecha_actual()) THEN true
    WHEN (fecha < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));

ALTER POLICY "bp update" ON siper.novedades_vigentes
    USING ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_vigentes.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_vigentes.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (fecha > siper.fecha_actual()) THEN true
    WHEN (fecha < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));

ALTER POLICY "bp delete" ON siper.novedades_vigentes
    USING ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_vigentes.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_vigentes.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (fecha > siper.fecha_actual()) THEN true
    WHEN (fecha < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));
ALTER TABLE IF EXISTS siper.bandas_horarias
    ADD COLUMN umbral_aviso_falta_entrada integer;

ALTER TABLE IF EXISTS siper.bandas_horarias
    ADD COLUMN umbral_aviso_falta_salida integer;


ALTER POLICY "bp insert" ON siper.novedades_registradas
    WITH CHECK ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_registradas.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_registradas.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (desde > siper.fecha_actual()) THEN true
    WHEN (desde < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));

ALTER POLICY "bp update" ON siper.novedades_registradas
    USING ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_registradas.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_registradas.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (desde > siper.fecha_actual()) THEN true
    WHEN (desde < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));

ALTER POLICY "bp delete" ON siper.novedades_registradas
    USING ((( SELECT roles.puede_cargar_todo
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) OR ( SELECT roles.puede_cargar_propio
   FROM siper.roles
  WHERE ((roles.rol = siper.get_app_user('rol'::text)) AND (novedades_registradas.idper = siper.get_app_user('idper'::text)))) OR (( SELECT roles.puede_cargar_dependientes
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text))) AND ( SELECT siper.sector_pertenece(( SELECT personas.sector
           FROM siper.personas
          WHERE (personas.idper = novedades_registradas.idper)), siper.get_app_user('sector'::text)) AS sector_pertenece))) AND (
CASE
    WHEN (desde > siper.fecha_actual()) THEN true
    WHEN (desde < siper.fecha_actual()) THEN false
    ELSE ( SELECT ((siper.fecha_hora_actual() - (siper.fecha_actual())::timestamp without time zone) <= (parametros.carga_nov_hasta_hora)::interval)
       FROM siper.parametros)
END OR ( SELECT roles.puede_corregir_el_pasado
   FROM siper.roles
  WHERE (roles.rol = siper.get_app_user('rol'::text)))));
ALTER TABLE IF EXISTS siper.perfiles_sgc DROP CONSTRAINT IF EXISTS puestos_sgc_pkey;

ALTER TABLE IF EXISTS siper.perfiles_sgc
    ADD CONSTRAINT perfiles_sgc_pkey PRIMARY KEY (perfil_sgc);
CREATE OR REPLACE TRIGGER changes_trg
    AFTER INSERT OR DELETE OR UPDATE 
    ON siper.perfiles_sgc
    FOR EACH ROW
    EXECUTE FUNCTION his.changes_trg('perfil_sgc');
REVOKE ALL ON TABLE siper.personas_importadas FROM siper_muleto_admin;
REVOKE ALL ON TABLE siper.personas_importadas FROM siper_muleto_owner;
GRANT DELETE, INSERT, SELECT, UPDATE ON TABLE siper.personas_importadas TO siper_muleto_admin;

GRANT ALL ON TABLE siper.personas_importadas TO siper_muleto_owner;
CREATE OR REPLACE FUNCTION siper.registrar_fichadas(
	p_data_json_text text)
    RETURNS jsonb
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$

DECLARE
    -- Variables de control de Bitácora y Estado
    v_bitacora_id BIGINT;
    v_start_time TIMESTAMP WITH TIME ZONE := now();
    v_has_error BOOLEAN := FALSE;
    v_end_status TEXT := 'OK';
    v_error_message TEXT;
    
    v_status_code INTEGER := 200; 
    
    -- Contadores
    v_cant_insertadas INTEGER := 0;      
    v_cant_procesadas INTEGER := 0;      
    v_cant_fallidas INTEGER := 0;        
    v_fallidas JSONB := '[]'::jsonb;     
    
    v_username TEXT := current_user; 
    v_fichadas_array jsonb;
    v_is_structurally_valid BOOLEAN := TRUE; 
    v_is_enabled BOOLEAN; 
    
    v_fichada JSONB; 
    v_idx INTEGER := 0;
    v_fallas_condensed TEXT := '';
    v_resultado jsonb; 
    
    v_fixed_machine_id CONSTANT TEXT := 'proceso bp'; 
    v_fixed_navigator CONSTANT TEXT := 'app fichadas'; 

BEGIN
    
    -- -------------------------------------------------------------------
    -- CHEQUEO PREVIO 1: Casteo del TEXT de entrada a JSONB (Directo a v_fichadas_array)
    -- -------------------------------------------------------------------
    BEGIN
        v_fichadas_array := p_data_json_text::jsonb;
    EXCEPTION
        WHEN data_exception THEN
            -- Manejo de error si el texto no es JSON válido (Error 400)
            v_resultado := jsonb_build_object('status', 'ERROR', 'code', 400, 'message', 'El formato de entrada no es JSON válido.', 'cant_procesadas', 0, 'cant_insertadas', 0, 'cant_fallidas', 0, 'fallidas', '[]'::jsonb);
            RETURN v_resultado; 
    END;
    
    -- -------------------------------------------------------------------
    -- CHEQUEO PREVIO 2: Validación Estructural (Debe ser un array)
    -- -------------------------------------------------------------------
    
    -- La asignación v_fichadas_array := v_data_json ha sido removida/fusionada con el paso 1.
    
    IF jsonb_typeof(v_fichadas_array) <> 'array' THEN
        v_is_structurally_valid := FALSE;
        v_has_error := TRUE;
        v_status_code := 400;
        v_end_status := '400 BAD REQUEST: La entrada JSON debe ser un array de fichadas.';
        v_error_message := 'Fallo en el formato de entrada (se esperaba un array).';
        v_cant_procesadas := 0;
        
    ELSE
        SELECT jsonb_array_length(v_fichadas_array) INTO v_cant_procesadas;
    END IF;
    
    -- -------------------------------------------------------------------
    -- PASO 1: REGISTRO INICIAL EN BITÁCORA 
    -- -------------------------------------------------------------------
    INSERT INTO his.bitacora (
        procedure_name, parameters, username, machine_id, navigator, init_date, end_status
    ) VALUES (
        'registrar_fichadas', v_fichadas_array::TEXT, v_username, v_fixed_machine_id, v_fixed_navigator, v_start_time, 'INICIADO'
    ) RETURNING id INTO v_bitacora_id;
    
    -- -------------------------------------------------------------------
    -- PASO 1.5: OBTENER ESTADO DE HABILITACIÓN 
    -- -------------------------------------------------------------------
    SELECT permite_cargar_fichadas
    INTO v_is_enabled
    FROM parametros
    WHERE unico_registro = TRUE;

    -- -------------------------------------------------------------------
    -- CHEQUEO DE HABILITACIÓN FUNCIONAL (Error 403)
    -- -------------------------------------------------------------------
    IF v_is_structurally_valid AND COALESCE(v_is_enabled, FALSE) IS FALSE THEN
        v_has_error := TRUE;
        v_status_code := 403;
        v_end_status := '403 FORBIDDEN: Funcionalidad de procesamiento de fichadas deshabilitada por configuración.';
        v_error_message := 'La funcionalidad de procesamiento de fichadas se encuentra deshabilitada.';
    END IF;
    
    
    -- -------------------------------------------------------------------
    -- PASO 2: LÓGICA DE INSERCIÓN Y CAPTURA DE FALLOS (Best-Effort Loop)
    -- -------------------------------------------------------------------
    IF v_is_structurally_valid AND v_status_code = 200 AND v_cant_procesadas > 0 THEN 
        
        FOR v_fichada IN SELECT * FROM jsonb_array_elements(v_fichadas_array) LOOP
            v_idx := v_idx + 1;
            
            BEGIN
                INSERT INTO fichadas (
                    idper, tipo_fichada, fecha, hora, observaciones, punto, tipo_dispositivo, id_original
                ) 
                VALUES (
                    v_fichada->>'idper', 
                    v_fichada->>'tipo_fichada', 
                    (v_fichada->>'fecha')::DATE,
                    (v_fichada->>'hora')::TIME WITH TIME ZONE,
                    v_fichada->>'observaciones',
                    v_fichada->>'punto',
                    v_fichada->>'tipo_dispositivo', -- MODIFICADO: COALESCE eliminado
                    v_fichada->>'id_original'
                );
                
                v_cant_insertadas := v_cant_insertadas + 1;

            EXCEPTION
                WHEN OTHERS THEN
                    v_has_error := TRUE; 
                    v_cant_fallidas := v_cant_fallidas + 1;
                    
                    v_fallidas := v_fallidas || jsonb_build_object(
                        'index', v_idx, 
                        'error_code', SQLSTATE,
                        'error_message', TRANSLATE(SQLERRM, chr(10), ' '), 
                        'fichada_data', v_fichada 
                    );
                    
                    CONTINUE; 
            END;
            
        END LOOP; 

        IF v_cant_fallidas > 0 AND v_cant_insertadas > 0 THEN
            v_status_code := 207; -- Éxito parcial
            v_end_status := '207 PARTIAL FAILURE: ' || v_cant_fallidas || ' fallaron (' || v_cant_insertadas || ' OK).';
            v_error_message := 'Lote procesado con fallos. Revise "fallidas" y end_status de bitácora.';
        END IF;

    END IF; 
    
    -- -------------------------------------------------------------------
    -- AJUSTE DE ESTADO FINAL (500/200/207)
    -- -------------------------------------------------------------------
    
    IF v_status_code = 200 AND v_cant_procesadas > 0 AND v_cant_insertadas = 0 THEN
        v_has_error := TRUE;
        v_status_code := 500;
        v_end_status := '500 ALL FAILED: Ninguna fichada pudo ser insertada.';
        v_error_message := 'Error fatal de procesamiento: Todas las fichadas del lote fallaron.';
    
    ELSIF v_status_code = 200 THEN
        v_end_status := format('200 OK: %s fichadas insertadas.', v_cant_insertadas);
        v_error_message := COALESCE(v_error_message, 'Lote procesado con éxito.');
    END IF;
    
    -- -------------------------------------------------------------------
    -- PASO 3: INCLUIR JSON DE FALLAS EN END_STATUS Y ACTUALIZAR BITÁCORA
    -- -------------------------------------------------------------------
    IF v_cant_fallidas > 0 THEN
        v_fallas_condensed := TRANSLATE(v_fallidas::TEXT, chr(10), ' ');
        v_end_status := v_end_status || ' | FALLAS_JSON: ' || v_fallas_condensed;
    END IF;
    
    UPDATE his.bitacora
    SET 
        end_date = now(),
        has_error = v_has_error,
        end_status = v_end_status 
    WHERE id = v_bitacora_id;
    
    
    -- -------------------------------------------------------------------
    -- PASO 4: PREPARAR Y RETORNAR SALIDA
    -- -------------------------------------------------------------------
    v_resultado := jsonb_build_object(
        'status', CASE 
            WHEN v_status_code = 500 THEN 'ERROR'
            WHEN v_status_code = 403 THEN 'ERROR' 
            WHEN v_status_code = 400 THEN 'ERROR'
            WHEN v_status_code = 207 THEN 'SUCCESS_PARTIAL'
            ELSE 'OK' 
        END,
        'code', v_status_code,
        'message', v_error_message,
        'cant_procesadas', v_cant_procesadas, 
        'cant_insertadas', v_cant_insertadas,
        'cant_fallidas', v_cant_fallidas,
        'fallidas', v_fallidas 
    );
    
    RETURN v_resultado;

EXCEPTION
    -- Captura errores FATALES
    WHEN OTHERS THEN
        v_resultado := jsonb_build_object(
            'status', 'ERROR',
            'code', 500,
            'message', 'Fallo interno fatal e irrecuperable de la función: ' || SQLERRM,
            'cant_procesadas', v_cant_procesadas,
            'cant_insertadas', 0,
            'cant_fallidas', v_cant_fallidas,
            'fallidas', v_fallidas
        );
        
        RETURN v_resultado; 
END;
$BODY$;

ALTER FUNCTION siper.registrar_fichadas(text)
    OWNER TO siper_muleto_owner;

CREATE OR REPLACE FUNCTION siper.fecha_actual(
	)
    RETURNS date
    LANGUAGE 'sql'
    COST 100
    STABLE PARALLEL UNSAFE
AS $BODY$

    SELECT date_trunc('day', fecha_hora_actual());
$BODY$;

ALTER FUNCTION siper.fecha_actual()
    OWNER TO siper_muleto_owner;

CREATE OR REPLACE FUNCTION siper.fecha_hora_actual(
	)
    RETURNS timestamp without time zone
    LANGUAGE 'sql'
    COST 100
    STABLE PARALLEL UNSAFE
AS $BODY$

      SELECT coalesce(fecha_hora_para_test, current_timestamp)
        from parametros
        where unico_registro;
    
$BODY$;

ALTER FUNCTION siper.fecha_hora_actual()
    OWNER TO siper_muleto_owner;

CREATE OR REPLACE FUNCTION siper.annio_preparar(IN p_annio integer)
    RETURNS void
    LANGUAGE 'plpgsql'
    VOLATILE SECURITY DEFINER
    PARALLEL UNSAFE
    COST 100
    
AS $BODY$
BEGIN
  INSERT INTO annios (annio, abierto, anterior) VALUES (p_annio, false, (SELECT annio FROM annios WHERE annio = p_annio - 1 ));
  INSERT INTO fechas (fecha) 
    SELECT d FROM generate_series(make_date(p_annio,1,1), make_date(p_annio,12,31), '1 day'::INTERVAL) d;
END;
$BODY$;
CREATE OR REPLACE PROCEDURE siper.inicializar_per_nov_cant(
	IN p_annio integer,
	IN p_idper text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
    SECURITY DEFINER 
AS $BODY$
BEGIN
  INSERT INTO per_nov_cant (annio, cod_nov, idper, origen, cantidad)
    SELECT p_annio,
        c.cod_nov,
        p.idper,
        CASE c.inicializacion WHEN 'LICORD' THEN 'TRAS' ELSE p_annio::text END as origen,
        CASE c.inicializacion WHEN 'PLANTA' THEN c.inicializacion_limite ELSE 0 END as cantidad
      FROM cod_novedades c,
        personas p
      WHERE p.activo 
        AND EXISTS (
          SELECT 1 
            FROM trayectoria_laboral INNER JOIN situacion_revista USING (situacion_revista) 
            WHERE ini_per_nov_cant 
              AND p_annio BETWEEN extract(YEAR from desde) AND extract(YEAR from coalesce(hasta,'9999-12-31'))
        )
        AND c.inicializacion = 'PLANTA'
        AND (p_idper IS NULL OR p.idper = p_idper);
END;
$BODY$;
ALTER PROCEDURE siper.inicializar_per_nov_cant(integer, text)
    OWNER TO siper_muleto_owner;


DROP PROCEDURE IF EXISTS siper.avance_de_dia_proc();

CREATE OR REPLACE FUNCTION siper.parametros_trg()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    VOLATILE
    COST 100
AS $BODY$
BEGIN
  UPDATE fechas f
    SET cod_nov_pred_fecha = cod_nov_habitual
    FROM parametros, annios a
    WHERE cod_nov_pred_fecha is null
      AND fecha <= fecha_actual()
      AND f.annio = a.annio
      AND a.abierto;
  RETURN new;
END;
$BODY$;
CREATE SEQUENCE IF NOT EXISTS siper.id_fichada_seq
    INCREMENT 1
    START 101
    MINVALUE 1
    MAXVALUE 9223372036854775807
    CACHE 1;

ALTER SEQUENCE siper.id_fichada_seq
    OWNER TO siper_muleto_owner;

GRANT SELECT, USAGE ON SEQUENCE siper.id_fichada_seq TO siper_muleto_admin;

GRANT ALL ON SEQUENCE siper.id_fichada_seq TO siper_muleto_owner;
